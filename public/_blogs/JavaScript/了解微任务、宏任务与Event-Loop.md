# 彻底理解事件循环、宏任务、微任务

## 总结

> * 事件循环：JS采用单线程的事件循环方式管理异步任务，优点是简化编程模型，缺点是无法发挥CPU的全部性能（但对前端其实没影响）
>
> - 任务队列：JS采用非抢断式运行，当前任务不会被打断，有新的异步任务时，会放入任务队列
> - 宏任务、微任务：宏任务就是普通异步任务，是最早出现的，微任务更关乎用户体验，所以得到优先执行
> - 常见宏任务：定时器、IO任务
> - 常见微任务：queueMicrotask、await、then

### 什么是事件循环、JS代码的内在执行机制

#### 1. 什么是事件循环？

> 所有的语言都拥有并发模型的概念，也就是说多个任务如何同时执行，大部分语言支持多线程执行，JS拥有所有语言中最简单的并发模型——JS使用单线程的"**事件循环(Event Loop)**"来处理多个任务的执行

* 简单来说，js的事件循环，每次读取一个任务，然后执行这个任务，执行完再继续获取下一个，如果暂时没有任务，就暂停执行，等待下一个任务到来；如果在执行任务的过程中有新的任务到达，也不会中断现有任务的执行，而是添加到队列的尾部等待
* 结论是，JS使用**基于事件循环的单线程执行方式**，而且是**非抢断**执行的（也就是说，无论发生什么，都会把当前任务执行完，不会出现执行到一半就去执行别的任务的情况）

|      | 多线程(C、Java等语言)           | 单线程事件驱动(JavaScript)                      |
| ---- | ------------------------ | ---------------------------------------- |
| 复杂性  | 复杂度高，需要面对线程间同步等大量消耗头发的问题 | 简单易于使用，永远不会出现资源争抢的问题                     |
| 性能   | CPU性能很高，适合计算密集型任务        | 单一线程，无法发挥CPU的极限性能（可通过webWorker补充），不过前端应用本就不是计算密集型的 |
| 阻塞   | 不会阻塞，大型任务可以单开线程处理        | 其实也不会阻塞，因为JS中的IO任务都是异步的（文件、网络），虽然大型计算任务依然会阻塞UI线程，但这种情况对前端其实不多 |

所以，JS的单线程事件循环其实很适合前端使用，大幅的简化了程序的复杂度，同时前端少会有大型计算任务，所以性能也并非问题

结论：**单线程事件循环看着好像"有点low"，但其实非常适合前端开发**

### 任务队列的概念

理解了事件循环的概念，我们来继续看看任务队列，所谓**任务队列，其实就是保存待处理任务的一个数组**

每当我们要执行一个新的任务（例如：定时器），我们就会在队列尾部添加一个task，等到当前任务完成，事件循环会去队列头部寻找下一个可执行任务，我们用一个例子来更好的理解这一点

```js
console.log('aaaa');

setTimeout(()=>{
  console.log('cccc');
}, 0);  //这个0毫秒是重点

console.log('bbbb');
/*控制台输出
aaaa
bbbb
cccc
*/
```

- 第1步：它会先执行`console.log('aaaa')`，很普通的同步代码
- 第2步：定时器是这个问题的关键，尤其是0毫秒的
  - 0毫秒意味着没有延迟，所以**本应**直接执行console.log('cccc')，但是...
  - 定时器不会立刻执行，因为它不能打断当前任务（JS是非抢断执行），所以它只能被放到队列的尾部
- 第3步：执行`console.log('bbb')`
- 第4步：当前任务已经执行完成了，这时才会从任务队列中寻找下一个任务（也就是之前放入的定时器任务）
- 第5步：执行定时器任务，也就是`console.log('cccc')`

总结：

- 正在执行的任务（比如上面的console.log aaa和bbb）永远不会被打断，所有异步代码会被添加到队列等待执行
- 定时器不论时间多短（哪怕是0）也不会立刻执行，而是被放到任务队列尾部

#### 题外话：定时器为什么总是不准？

大家一定注意过一个事情，那就是JS中的定时器经常不准（其实所有语言都这样），这个问题也跟上面的任务队列有关

- 定时器的时间，**并不是函数执行的时间**，而是"最短x毫秒后，将任务添加到队列中"
- 也就是说，除非队列完全是空的，否则定时器的时间到了，它仅仅是开始排队罢了
- 那么，队列有可能永远是空的吗？显然不可能，就算没有你的任务，浏览器也有很多它的工作——渲染、重排、清理内存什么的

所以结论就是，因为有其他任务在排队，定时器永远不可能完全准时

```js
console.log('aaa');

setTimeout(() => console.log(111), 0);
setTimeout(() => console.log(222), 0);

console.log('bbb');
/*控制台输出
aaa
bbb
111
222
*/
```

### 宏任务？微任务？（**微任务就是得到优先执行的异步任务**）

其实js里任务队列不只有一条，而是有两条，而且有一条还是SVIP年费白金队列

- 宏任务（macroTask或简称Task）：普通的任务，正常执行
- 微任务（microTask）：SVIP年费白金会员任务，优先于宏任务执行（但依然是非抢断的）

## 注意：async的坑

上面我们说到Promise也是微任务，而且async就是promise的一种语法包装（所谓语法糖），那async是不是一定是按照微任务的方式执行呢？"不全是"

```js
console.log('aaa');

(async ()=>{
  console.log(111);  //在async里面
})().then(()=>{
  console.log(222);  //在async的then里面
});

console.log('bbb');
/*控制台输出
aaa
111
bbb
222
*/
```

分析：

- 第2步，虽然`async`是异步操作，但async函数本身（也就是111所在的()=>{}），其实依然是同步执行的，除非有await出现，这个下面会说，所以，这里`111`会**直接同步执行**，而不是放到队列里等待
- 第3步，重点来了，`then`不会同步执行，它才是异步的，而且是一个微任务，所以`222`不会立即执行，而是排到队列尾部

###await

再来看看await的作用吧，await其实是异步的，跟then差不多（从语法上来说，await其实就是promise的then）

```js
console.log('aaa');

(async ()=>{
  console.log(111);
  await console.log(222);
  console.log(333);
})().then(()=>{
  console.log(444);
});

console.log('ddd');
/*控制台输出
aaa
111
222
ddd
333
444
*/
```

- 第3步、`222`这里很重要了，首先，console.log自己是同步的，所以**立即就会执行**，我们能直接看到`222`，但是`await`本身就是`then`，所以`console.log(333)`无法直接执行，而是老老实实去排队，而且，因为整个async并未执行完，它的then（也就是444）无法触发
- 第5步、从任务队列中把`333`拉出来，并且执行了，这时整个async才算完成，所以把then推到队列中等待执行

## 结论：

await其实等价于then（事实上他俩也确实是一个东西），都是将后续任务放到微任务队列中等待，而不会立即执行

参考文章：[🔥「吊打面试官」彻底理解事件循环、宏任务、微任务 - 掘金 (juejin.cn)](https://juejin.cn/post/6894078909592109069)

