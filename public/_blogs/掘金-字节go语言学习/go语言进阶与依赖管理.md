# go语言进阶与依赖管理|测试与项目实践

1. 语言进阶：从并发编程视角了解Go高性能的本质

   > 1. 并发 vs 并行：go可以充分发挥多喝优势，高效运行
   >
   >    > 1. 多线程程序在一个核的cpu上运行
   >    > 2. 多线程程序在多个核的cpu上运行
   >
   > 2. 协程：Goroutine
   >
   >    > 1. 协程：用户态，轻量级线程，栈KB级别，由go语言本身创建和调度
   >    >
   >    > 2. 线程：内核态，线程跑多个协程，栈MB级别
   >    >
   >    > 3. 协程的创建和使用（快速）：调用函数的时候，在函数之前加一个go关键字就可以创建出一个协程来运行函数
   >    >
   >    > 4. CSP：提倡通过通信共享内存而不是通过共享内存而实现通信
   >    >
   >    > 5. Channel（通道）：
   >    >
   >    >    > make(chan 元素类型,[缓冲大小])
   >    >    >
   >    >    > * 无缓冲通道 make(chan int)
   >    >    > * 有缓冲通道 make(chan int,2)
   >    >    >
   >    >    > 无缓冲通道为同步通道，有缓冲通道为经典的生产消费模型
   >    >
   >    >    > 注：Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。
   >    >
   >    > 6. 并发安全Lock
   >    >
   >    > 7. WaitGroup
   >    >
   >    >    > 计数器：开启协程+1；执行结束-1；主协程阻塞直到计数器为0。

2. 依赖管理：了解Go语言依赖管理的演进路线和Go Module依赖管理方案

   > 1. 背景
   >
   >    > * 工程项目不可能基于标准库0~1编码搭建；
   >    > * 管理依赖库
   >
   > 2. go依赖管理演进
   >
   >    > GOPATH——>Go Vendor——>Go Module
   >    >
   >    > * 不同环境（项目）依赖的版本不同；
   >    > * 控制依赖库的版本；
   >    >
   >    > 1. GOPATH
   >    >
   >    >    * 环境变量$GOPATH
   >    >    * 项目代码直接依赖src下的代码
   >    >    * go get 下载最新版本的包到src目录下
   >    >
   >    >    1. 弊端
   >    >
   >    >       场景：A和B依赖于某一个package的不同版本
   >    >
   >    >       问题：无法实现package的多版本控制
   >    >
   >    > 2. Go Vendor
   >    >
   >    >    * 项目目录下增加vendor文件，所有依赖包副本形式放在$ProjectRoot/vendor
   >    >    * 依赖寻址方式：vendor——>GOPATH
   >    >    * 通过每个项目引入一份依赖的副本，解决了多个项目需要同一个package依赖的冲突问题
   >    >
   >    >    1. 弊端
   >    >       * 无法控制依赖的版本
   >    >       * 更新项目又可能出现依赖冲突，导致编译出错
   >    >
   >    > 3. Go Module
   >    >
   >    >    * 通过go.mod文件管理依赖包版本；
   >    >    * 通过go get/go mod指令工具管理依赖包
   >    >    * 终极目标：定义版本规则和管理项目依赖关系
   >    >
   >    > 4. 依赖管理三要素
   >    >
   >    >    1. 配置文件，描述依赖 go.mod
   >    >    2. 中心仓库管理依赖库 Proxy
   >    >    3. 本地工具 go get/mod
   >    >
   >    >    > 1. 依赖配置-go.mod
   >    >    >
   >    >    >    * 依赖管理基本单元
   >    >    >    * 原生库
   >    >    >    * 单元依赖
   >    >    >    * 依赖标识：[Module Path]\[Version/Pseudo-version]
   >    >    >
   >    >    > 2.  依赖配置-version
   >    >    >
   >    >    >    * 语义化版本
   >    >    >
   >    >    >      ${MAJOR}.\${MINOR}.\${PATCH}
   >    >    >
   >    >    >      V1.3.0
   >    >    >
   >    >    >      V2.3.0
   >    >    >
   >    >    >    * 基于commit伪版本
   >    >    >
   >    >    >      vX.0.0-yyyymmddhhmmss-abcdefgh1234
   >    >    >
   >    >    > 3. 依赖配置-indirect
   >    >    >
   >    >    >    A->B->C 直接依赖和间接依赖(indirect)
   >    >    >
   >    >    > 4. 依赖配置-incompatible
   >    >    >
   >    >    >    * 主版本2+模块会在模块路径增加/vN后缀
   >    >    >    * 对于没有go.mod文件并且主版本2+的依赖，会+incompatible
   >    >    >
   >    >    > 5. 依赖配置-依赖图：选择最低的兼容版本
   >    >    >
   >    >    > 6. 依赖分发-回源：直接使用版本管理仓库下载依赖
   >    >    >
   >    >    >    * 无法保证构建稳定性：增加/修改/删除软件版本
   >    >    >    * 无法保证依赖可用性：删除软件
   >    >    >    * 增加第三方压力：增加托管平台负载问题
   >    >    >
   >    >    > 7. 依赖分发-Proxy：下载依赖后缓存依赖
   >    >    >
   >    >    >    * 稳定可靠
   >    >    >
   >    >    > 8. 依赖分发-变量GOPROXY
   >    >    >
   >    >    >    * GOPROXY="https://proxy1.cn,https://proxy2.cn,direct"
   >    >    >    * 服务站点URL列表，“direct”表示源站
   >    >    >    * Proxy1——>Proxy2——>Direct
   >    >    >
   >    >    > 9. 工具-go get
   >    >    >
   >    >    >    * $$go get example.org/pkg \begin{cases} @update &默认 \\ @none  &删除依赖 \\ @v1.1.2 &tag版本，语义版本\\@23dfdd5 &特定的commit\\@master &分支最新的commit\end{cases}$$
   >    >    >    * $$go mod \begin{cases} init &初始化，创建go.mod文件\\ download &下载模块到本地缓存\\ tidy &增加需要的依赖，删除不需要的依赖\end{cases}$$

3. 测试：从单元测试实践触发，提升质量意识{单元测试|Mock测试|基准测试}

   > 1. 事故案例
   >
   >    * 营销配置错误，导致非预期用户享受权益；
   >    * 用户提现，幂等失效，短时间可以多次提现；
   >    * 代码逻辑错误，广告位被占，无法出广告；
   >    * 代码指针使用错误，导致APP不可用；
   >
   > 2. 测试是避免事故的最后一道屏障
   >
   >    * 测试分为回归测试、集成测试、单元测试：覆盖层逐层变大，成本逐层降低
   >      * 回归测试：QA终端手动测试
   >      * 集成测试：系统功能维度测试，自动化接口测试
   >      * 单元测试：开发时，面对功能函数测试
   >
   >    1. 单元测试：输入、测试单元、输出、期望值{输出与期望值校对}——>保证质量、提升效率（方便定位问题）
   >
   >       1. 规则
   >
   >          * 所有测试文件以_test.go结尾
   >          * func TestXxx(*testing.T)
   >          * 初始化逻辑放到TestMain函数中
   >
   >       2. 评估单元测试-代码覆盖率
   >
   >       3. 覆盖率-Tip
   >
   >          * 一般覆盖率：50%~60%，较高覆盖率80%+
   >          * 测试分支相互独立、全面覆盖
   >          * 测试单元粒度足够小，函数单一职责
   >
   >       4. 依赖：{外部依赖=》稳定&幂等}
   >
   >          > ${单元\begin{cases}File\\DB\\Cache\end{cases}}$——>${Mock\begin{cases}幂等\\稳定\end{cases}}$
   >
   >       5. Mock（monky：https://github.com/bouk/monkey）
   >
   >          > 快速Mock函数
   >          >
   >          > * 为一个函数打桩
   >          > * 为一个方法打桩
   >          >
   >          > 对函数进行打桩测试，不再依赖本地文件
   >
   >       6. 基准测试：对代码进行性能分析
   >
   >          * 优化代码，需要对当前代码分析
   >
   >          * 内置的测试框架提供了基准测试能力
   >
   >            <hr/>
   >
   >          * 基准测试为BenchmarkXxxx(b *testing.B)  支持串行和并行
   >
   >          * 基准测试优化fastrand.Intn()  牺牲了一定基准序列的一致性
   >

4. 项目实战：通过项目需求、需求拆解、逻辑设计、代码实现感受真实的项目开发（需求设计|代码开发|测试运行）

   > * 需求描述：社区话题页面
   >
   >   * 展示话题（标题、文字描述）和回帖列表
   >   * 暂不考虑前端页面实现，仅仅实现一个本地web服务
   >   * 话题和回帖数据用文件存储
   >
   > * 需求用例：$User\begin{cases}Topic &id,title,content,create_time\\Post &id,topic_id,content,create_time\end{cases}$
   >
   > * ER图
   >
   > * 分层结构
   >
   >   * 数据层：数据Model,外部数据的增删改查（关联数据模型，屏蔽下层数据差异）
   >   * 逻辑层：业务Entity，处理核心业务逻辑输出（不需要关心底层数据存储，对数据层的数据进行打包封装）
   >   * 视图层：视图view，处理和外部的交互逻辑（对逻辑实体包装数据格式等）
   >
   > * 组件工具
   >
   >   * Gin高性能go web框架 https://github.com/gin-gonic/gin#installation
   >   * Go Mod
   >     * go mod init
   >     * go get gopkg.in/gin-gonic/gin.v1@v1.3.0
   >
   > * Repository
   >
   >   * Topic  QueryTopicById
   >   * Post    QueryPostsByParentId
   >
   > * Repository-index
   >
   >   * 元数据 数据行——>索引 内存Map
   >   * 初始化话题数据索引
   >
   > * Repository-查询
   >
   >   * 索引：话题ID    数据：话题
   >   * 索引：话题ID    数据：帖子列表
   >
   > * Service
   >
   >   * 实体
   >   * 流程：参数校验——>准备数据——>组装实体
   >   * 代码流程编排
   >     * 并行处理  话题信息，回帖信息获取并行处理
   >     * 可用性
   >
   > * Controller
   >
   >   * 构建View对象
   >   * 业务错误码
   >
   > * Router
   >
   >   * 初始化数据索引
   >   * 初始化引擎配置
   >   * 构建路由
   >   * 启动服务
   >
   > * 课后实践
   >
   >   * 支持发布帖子
   >   * 本地ID生成需要保证不重复、唯一性
   >   * Append文件，更新索引，注意Map的并发安全问题
   >
   >   ​

